local _M = getfenv(1);
if pyscripter then
  exit(__import__('pc').main());
end;


local startup = os.clock();
if _M == _G or rawget(_M, 'shell') then
  _M = setmetatable({['_G'] = _G}, {['__index'] = _G});
  setfenv(1, _M);
else
end;
local lua = {};
lua.len = (function(obj) return #obj; end);
lua.concat = (function(...) return table.concat({...}); end);
lua.write = write or io.write;
lua.yield_ = coroutine['yield'];
lua.format = string.format;
for key, value in pairs(_G) do
  lua[key] = value;
end;
local PY_OBJ_TAG = '#';
local LUA_OBJ_TAG = '@';
local BIT_WIDTH = 8;
local TAG = '[PY]';
local ObjLastID = 0;
local inited = False;
local builtins = 'builtins';
local ObjData = setmetatable({}, {['__mode'] = 'k'});
local ObjPCEX = setmetatable({}, {['__mode'] = 'k'});
local Obj_FromID = setmetatable({}, {['__mode'] = 'v'});
local BuiltinTypes = setmetatable({}, {['__mode'] = 'k'});
local InitalBuiltinTypes = {};
local metatable_events = {'__index', '__newindex', '__mode', '__call', '__metatable', '__tostring', '__len', '__gc', '__unm', '__add', '__sub', '__mul', '__div', '__mod', '__pow', '__concat', '__eq', '__lt', '__le'};
local metatable_events_rev = {};
for k, v in pairs(metatable_events) do
  metatable_events_rev[v] = k;
end;
local builtin_methods = {'__new__', '__init__', '__del__', '__repr__', '__str__', '__bytes__', '__format__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__hash__', '__bool__', '__getattr__', '__getattribute__', '__setattr__', '__delattr__', '__dir__', '__get__', '__set__', '__delete__', '__slots__', '__call__', '__len__', '__getitem__', '__setitem__', '__delitem__', '__iter__', '__reversed__', '__contains__', '__add__', '__sub__', '__mul__', '__truediv__', '__floordiv__', '__mod__', '__divmod__', '__pow__', '__lshift__', '__rshift__', '__and__', '__xor__', '__or__', '__radd__', '__rsub__', '__rmul__', '__rtruediv__', '__rfloordiv__', '__rmod__', '__rdivmod__', '__rpow__', '__rlshift__', '__rrshift__', '__rand__', '__rxor__', '__ror__', '__iadd__', '__isub__', '__imul__', '__itruediv__', '__ifloordiv__', '__imod__', '__ipow__', '__ilshift__', '__irshift__', '__iand__', '__ixor__', '__ior__', '__neg__', '__pos__', '__abs__', '__invert__', '__complex__', '__int__', '__float__', '__round__', '__index__', '__enter__', '__exit__', '__lua__'};
local builtin_methods_rev = {};
for k, v in pairs(builtin_methods) do
  builtin_methods_rev[v] = k;
end;
assert(builtin_methods[42] == '__rshift__');
assert(builtin_methods_rev['__pos__'] == 72);
local error = nil;
local function is_float(num)
  if lua.type(num) ~= 'number' then
    error('This is not number', 2);
  end;
  return math.floor(num) ~= num;
end;
local function is_pyobj(obj)
  return ObjData[obj] ~= nil;
end;
function PObj(obj)
  if is_pyobj(obj) then
    return obj;
  else
    return LuaObject(obj);
  end;
end;
function LObj(obj)
  if is_pyobj(obj) then
    return _OP__Lua__(obj);
  else
    return obj;
  end;
end;
local function require_pyobj(...)
  local objs = {...};
  local idx, obj;
  for idx, obj in pairs(objs) do
    if not is_pyobj(obj) then
      error('Require python object.');
    end;
  end;
  return true;
end;
local raw_id = nil;
local function register_pyobj(obj, obj_id)
  if obj_id == nil then
    obj_id = raw_id(obj);
  end;
  assert(ObjData[obj] == nil);
  ObjData[obj] = {};
  ObjData[obj].i = obj_id;
  Obj_FromID[obj_id] = obj;
end;
function error(msg, level)
  if level == nil then
    level = 1;
  end;
  msg = LObj(msg);
  level = (level + 1);
  msg = lua.format('%s %s', TAG, tostring(msg));
  lua.error(msg, level);
end;
local function require_args(...)
  local args = {...};
  local value, key;
  for key, value in pairs(args) do
    if value == nil then
      error('SystemError: Not Enough Item');
    end;
  end;
  return True;
end;
local function nonrequire_args(...)
  local args = {...};
  local value, key;
  for key, value in pairs(args) do
    if value ~= nil then
      error('SystemError: Too Many Item');
    end;
  end;
  return True;
end;
function is_float(num)
  if lua.type(num) ~= 'number' then
    error('This is not number', 2);
  end;
  return math.floor(num) ~= num;
end;
local _C3_MRO = nil;
_C3_MRO = (function(_M)--(_C3_MRO)
  local scope = setmetatable({}, {__index=_M})
;scope.__bases__ = {};
  scope.__name__ = '_C3_MRO';
  function doload()
    function merge(seqs)
      local _, set_break, cand, nonemptyseqs, intail, seq;
      local res = {};
      while true do
        nonemptyseqs = {};
        for _, seq in ipairs(seqs) do
          if lua.len(seq) > 0 then
            table.insert(nonemptyseqs, seq);
          end;
        end;
        if lua.len(nonemptyseqs) == 0 then
          return res;
        end;
        cand = nil;
        set_break = false;
        for _, seq in ipairs(nonemptyseqs) do
          if not set_break then
            cand = seq[1];
            function intail()
              local _, nonemptyseq, j, cls;
              for _, nonemptyseq in ipairs(nonemptyseqs) do
                for j, cls in ipairs(nonemptyseq) do
                  if j > 1 and cls == cand then
                    return true;
                  end;
                end;
              end;
              return false;
            end;
            intail = intail();
            if not intail then
              set_break = true;
            else
              cand = nil;
            end;
          end;
        end;
        if not cand then
          error('Inconsistent hierarchy', 2);
        else
          table.insert(res, cand);
          for _, seq in ipairs(nonemptyseqs) do
            if seq[1] == cand then
              table.remove(seq, 1);
            end;
          end;
        end;
      end;
    end;
    setfenv(merge, _M);
    function mro(C)
      local _, base, mro;
      local mros = {};
      local basesCopy = {};
      table.insert(mros, {C});
      for _, base in ipairs(C.__bases__) do
        mro = _C3_MRO.get_cached_mro(base);
        if mro == nil then
          mro = _C3_MRO.mro(base);
        end;
        table.insert(mros, mro);
        table.insert(basesCopy, base);
      end;
      table.insert(mros, basesCopy);
      return _C3_MRO.merge(mros);
    end;
    setfenv(mro, _M);
    function get_cached_mro(C)
      local v, k;
      if not inited then
        if C.__mro__ == nil then
          return nil;
        end;
        local new_mro = {};
        for k, v in pairs(C.__mro__) do
          new_mro[k] = v;
        end;
        return new_mro;
      end;
      error('FAILED');
    end;
    setfenv(get_cached_mro, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
local function hide_class_from_seq(seq)
  local v, k;
  local new_seq = {};
  local idx = 1;
  for k, v in pairs(seq) do
    if InitalBuiltinTypes[v] ~= nil then
      new_seq[idx] = v;
      idx = (idx + 1);
    end;
  end;
  return new_seq;
end;
local function setup_base_class(cls)
  local idx, v, k;
  register_pyobj(cls);
  ObjData[cls].c = {};
  local clsdata = ObjData[cls].c;
  local pcex = {};
  for k, v in pairs(cls) do
    idx = builtin_methods_rev[k];
    if idx ~= nil then
      pcex[idx] = v;
    end;
  end;
  local pcls = getmetatable(cls);
  ObjPCEX[cls] = pcex;
  InitalBuiltinTypes[cls] = false;
  clsdata.__mro__ = _C3_MRO.mro(cls);
  return cls;
end;
local function setup_basic_class(cls)
  setup_base_class(cls);
  setmetatable(cls, type);
  return cls;
end;
local function setup_hide_class(cls)
  InitalBuiltinTypes[cls] = nil;
  return cls;
end;
local function register_builtins_class(cls)
  local clsdata = ObjData[cls].c;
  if cls ~= object then
    clsdata.__base__ = object;
  else
    clsdata.__base__ = None;
  end;
  clsdata.__name__ = str(cls.__name__);
  clsdata.__module__ = str('builtins');
  clsdata.__bases__ = tuple(hide_class_from_seq(cls.__bases__));
  clsdata.__mro__ = tuple(hide_class_from_seq(clsdata.__mro__));
  cls.__name__ = nil;
  cls.__bases__ = nil;
  InitalBuiltinTypes[cls] = true;
  return cls;
end;
local function Fail_OP(a, ax)
  error(lua.concat(LObj(repr(a)), ' are not support ', builtin_methods[ax]));
end;
local function Fail_OP_Raw(a, raw_ax)
  error(lua.concat(LObj(repr(a)), ' are not support ', raw_ax));
end;
local function Fail_OP_Math_Raw(a, b, raw_ax)
  error(lua.concat('Not support ', LObj(repr(a)), ' ', raw_ax, ' ', LObj(repr(b))));
end;
local function Fail_OP_Math(a, b, ax, extra)
  if extra == nil then
    extra = '';
  else
    extra = lua.concat(' ', extra);
  end;
  error(lua.concat('Not support ', LObj(repr(a)), ' ', builtin_methods[ax], ' ', LObj(repr(b)), extra));
end;
local function Fail_OP_Math_Pow(a, b, ax, c)
  local extra = '';
  if c then
    extra = lua.concat('% ', LObj(repr(c)));
  end;
  Fail_OP_Math(a, b, ax, c);
end;
local function OP_Call(ax)
  local function func(a, ...)
    local args = {...};
    assert(require_pyobj(a));
    local f = ObjPCEX[getmetatable(a)][ax];
    if f then
      return f(a, ...);
    end;
    Fail_OP(a, ax);
  end;
  return func;
end;
local function OP_Math1(vx, wx)
  local function func(v, w)
    assert(require_pyobj(v, w));
    local vm = ObjPCEX[getmetatable(v)];
    local wm = ObjPCEX[getmetatable(w)];
    local vf = vm[vx];
    if vm ~= wm then
      local wf = wm[wx];
      if vf == wf then
        wf = nil;
      end;
    end;
    if vf then
      if wf and issubclass(type(w), type(v)) then
        local x = wf(w, v);
        if x ~= NotImplemented then
          return x;
        end;
        wf = nil;
      end;
      x = vf(v, w);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    if wf then
      x = wf(w, v);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    Fail_OP_Math(v, w, vx);
  end;
  return func;
end;
local function OP_Math2(vx, wx, zx)
  local op = OP_Math1(wx, zx);
  local function func(v, w)
    assert(require_pyobj(v, w));
    local vm = ObjPCEX[getmetatable(v)];
    local vf = vm[vx];
    if vf then
      local x = vf(v, w);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    return op(v, w);
  end;
  return func;
end;
local function OP_Math1_Pow(vx, wx)
  local function func(v, w, z)
    assert(require_pyobj(v, w));
    local vm = ObjPCEX[getmetatable(v)];
    local wm = ObjPCEX[getmetatable(w)];
    local vf = vm[vx];
    if vm ~= wm then
      local wf = wm[wx];
      if vf == wf then
        wf = nil;
      end;
    end;
    if vf then
      if wf and issubclass(type(w), type(v)) then
        local x = wf(w, v, z);
        if x ~= NotImplemented then
          return x;
        end;
        wf = nil;
      end;
      x = vf(v, w, z);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    if wf then
      x = wf(w, v, z);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    Fail_OP_Math_Pow(v, w, vx, z);
  end;
  return func;
end;
local function OP_Math2_Pow(vx, wx, zx)
  local op = OP_Math1_Pow(wx, zx);
  local function func(v, w, z)
    assert(require_pyobj(v, w) and z == nil or require_pyobj(z));
    local vm = ObjPCEX[getmetatable(v)];
    local vf = vm[vx];
    if vf then
      local x = vf(v, w, z);
      if x ~= NotImplemented then
        return x;
      end;
    end;
    return op(v, w, z);
  end;
  return func;
end;
function _OP__Is__(a, b)
  require_pyobj(a, b);
  return bool(ObjData[a].i == ObjData[b].i);
end;
function _OP__IsNot__(a, b)
  return bool(not LObj(_OP__Is__(a, b)));
end;
function _OP__ForIter__(ret)
  return LObj(iter(ret));
end;
function _OP__SetupGenFunc__(func)
  local function func2()
    local function body(...)
      local args = {...};
      func(...);
    end;
    return generator(coroutine.create(body));
  end;
  return func2;
end;
local _OP__Yield__ = lua.yield_;
local function _OP__Call__(func, args, kwargs)
end;
local function _(name)
  return builtin_methods_rev[name];
end;

_OP__New__ = OP_Call(_('__new__'));
_OP__Init__ = OP_Call(_('__init__'));
_OP__Del__ = OP_Call(_('__del__'));
_OP__Repr__ = OP_Call(_('__repr__'));
_OP__Str__ = OP_Call(_('__str__'));
_OP__Bytes__ = OP_Call(_('__bytes__'));
_OP__Format__ = OP_Call(_('__format__'));
_OP__Lt__ = OP_Call(_('__lt__'));
_OP__Le__ = OP_Call(_('__le__'));
_OP__Eq__ = OP_Call(_('__eq__'));
_OP__Ne__ = OP_Call(_('__ne__'));
_OP__Gt__ = OP_Call(_('__gt__'));
_OP__Ge__ = OP_Call(_('__ge__'));
_OP__Hash__ = OP_Call(_('__hash__'));
_OP__Bool__ = OP_Call(_('__bool__'));
_OP__Getattr__ = OP_Call(_('__getattr__'));
_OP__Getattribute__ = OP_Call(_('__getattribute__'));
_OP__Setattr__ = OP_Call(_('__setattr__'));
_OP__Delattr__ = OP_Call(_('__delattr__'));
_OP__Dir__ = OP_Call(_('__dir__'));
_OP__Get__ = OP_Call(_('__get__'));
_OP__Set__ = OP_Call(_('__set__'));
_OP__Delete__ = OP_Call(_('__delete__'));
_OP__Slots__ = OP_Call(_('__slots__'));
_OP__RawCall__ = OP_Call(_('__call__'));
_OP__Len__ = OP_Call(_('__len__'));
_OP__Getitem__ = OP_Call(_('__getitem__'));
_OP__Setitem__ = OP_Call(_('__setitem__'));
_OP__Delitem__ = OP_Call(_('__delitem__'));
_OP__Iter__ = OP_Call(_('__iter__'));
_OP__Reversed__ = OP_Call(_('__reversed__'));
_OP__Contains__ = OP_Call(_('__contains__'));
_OP__Add__ = OP_Math1(_('__add__'), _('__radd__'));
_OP__Sub__ = OP_Math1(_('__sub__'), _('__rsub__'));
_OP__Mul__ = OP_Math1(_('__mul__'), _('__rmul__'));
_OP__Truediv__ = OP_Math1(_('__truediv__'), _('__rtruediv__'));
_OP__Floordiv__ = OP_Math1(_('__floordiv__'), _('__rfloordiv__'));
_OP__Mod__ = OP_Math1(_('__mod__'), _('__rmod__'));
_OP__Divmod__ = OP_Math1(_('__divmod__'), _('__rdivmod__'));
_OP__Pow__ = OP_Math1_Pow(_('__pow__'), _('__rpow__'));
_OP__Lshift__ = OP_Math1(_('__lshift__'), _('__rlshift__'));
_OP__Rshift__ = OP_Math1(_('__rshift__'), _('__rrshift__'));
_OP__And__ = OP_Math1(_('__and__'), _('__rand__'));
_OP__Xor__ = OP_Math1(_('__xor__'), _('__rxor__'));
_OP__Or__ = OP_Math1(_('__or__'), _('__ror__'));
_OP__Iadd__ = OP_Math2(_('__iadd__'), _('__add__'), _('__radd__'));
_OP__Isub__ = OP_Math2(_('__isub__'), _('__sub__'), _('__rsub__'));
_OP__Imul__ = OP_Math2(_('__imul__'), _('__mul__'), _('__rmul__'));
_OP__Itruediv__ = OP_Math2(_('__itruediv__'), _('__truediv__'), _('__rtruediv__'));
_OP__Ifloordiv__ = OP_Math2(_('__ifloordiv__'), _('__floordiv__'), _('__rfloordiv__'));
_OP__Imod__ = OP_Math2(_('__imod__'), _('__mod__'), _('__rmod__'));
_OP__Ipow__ = OP_Math2_Pow(_('__ipow__'), _('__pow__'), _('__rpow__'));
_OP__Ilshift__ = OP_Math2(_('__ilshift__'), _('__lshift__'), _('__rlshift__'));
_OP__Irshift__ = OP_Math2(_('__irshift__'), _('__rshift__'), _('__rrshift__'));
_OP__Iand__ = OP_Math2(_('__iand__'), _('__and__'), _('__rand__'));
_OP__Ixor__ = OP_Math2(_('__ixor__'), _('__xor__'), _('__rxor__'));
_OP__Ior__ = OP_Math2(_('__ior__'), _('__or__'), _('__ror__'));
_OP__Neg__ = OP_Call(_('__neg__'));
_OP__Pos__ = OP_Call(_('__pos__'));
_OP__Abs__ = OP_Call(_('__abs__'));
_OP__Invert__ = OP_Call(_('__invert__'));
_OP__Complex__ = OP_Call(_('__complex__'));
_OP__Int__ = OP_Call(_('__int__'));
_OP__Float__ = OP_Call(_('__float__'));
_OP__Round__ = OP_Call(_('__round__'));
_OP__Index__ = OP_Call(_('__index__'));
_OP__Enter__ = OP_Call(_('__enter__'));
_OP__Exit__ = OP_Call(_('__exit__'));
_OP__Lua__ = OP_Call(_('__lua__'));
function repr(obj)
  if is_pyobj(obj) then
    return _OP__Repr__(obj);
  else
    return lua.format('%s(%s)', LUA_OBJ_TAG, tostring(obj));
  end;
end;
function print(...)
  local args = {...};
  local _, arg;
  local arr = {};
  local idx = 1;
  for _, arg in pairs(args) do
    if is_pyobj(arg) then
      arg = str(arg);
    else
      arg = repr(arg);
    end;
    arg = LObj(arg);
    arr[idx] = arg;
    idx = (idx + 1);
  end;
  local data = table.concat(arr, ' ');
  data = lua.concat(data, '\n');
  lua.write(data);
end;
function isinstance(obj, targets)
  local _, supercls, target, k;
  require_pyobj(obj);
  local cls = type(obj);
  local mro = cls.__mro__;
  assert(type(mro) == tuple);
  if type(targets) == tuple then
    targets = LObj(targets);
  else
    targets = {targets};
  end;
  for _, supercls in pairs(_OP__Lua__(mro)) do
    require_pyobj(supercls);
    for k, target in pairs(targets) do
      if supercls == target then
        return True;
      end;
    end;
  end;
  return False;
end;
function issubclass(cls, targets)
  local _, supercls, target, k;
  require_pyobj(obj);
  if type(cls) ~= type then
    error('issubclass() arg 1 must be a class');
  end;
  local mro = cls.__mro__;
  assert(type(mro) == tuple);
  if type(targets) == tuple then
    targets = LObj(targets);
  else
    targets = {targets};
  end;
  for _, supercls in pairs(_OP__Lua__(mro)) do
    require_pyobj(supercls);
    for k, target in pairs(targets) do
      if supercls == target then
        return True;
      end;
    end;
  end;
  return False;
end;
function id(obj)
  if is_pyobj(obj) then
    return int(ObjData[obj].i);
  end;
  Fail_OP_Raw(obj, '__id!');
end;
function dir(obj)
  return _OP__Dir__(obj);
end;
function iter(ret)
  ret = _OP__Iter__(ret);
  if isinstance(ret, generator) == False then
    error(TypeError('iter are only accept generator!'));
  end;
  return ret;
end;
function len(obj)
  return _OP__Len__(obj);
end;

_ = nil;
local function _raw_id(obj)
  return tonumber(string.sub(tostring(obj), 8), 16);
end;
function raw_id(obj)
  if lua.type(obj) ~= 'table' then
    Fail_OP_Raw(obj, '__raw_id!');
  end;
  local cls = getmetatable(obj);
  if cls == nil then
    local obj_id = _raw_id(obj);
  else
    setmetatable(obj, nil);
    obj_id = _raw_id(obj);
    setmetatable(obj, cls);
  end;
  return obj_id;
end;
object = (function(_M)--(object)
  local scope = setmetatable({}, {__index=_M})
;scope.__bases__ = {};
  scope.__name__ = 'object';
  function doload()
    function __init__(self)
    end;
    setfenv(__init__, _M);
    function __call(self, ...)
      local args = {...};
      return _OP__RawCall__(self, ...);
    end;
    setfenv(__call, _M);
    function __index(self, key)
      return _OP__Getattribute__(self, key);
    end;
    setfenv(__index, _M);
    function __newindex(self, key, value)
      return _OP__Setattr__(self, key, value);
    end;
    setfenv(__newindex, _M);
    function __tostring(self)
      return lua.format('%s(%s)', PY_OBJ_TAG, LObj(repr(self)));
    end;
    setfenv(__tostring, _M);
    function __new__(cls, ...)
      local args = {...};
      local instance = {};
      register_pyobj(instance, _raw_id(instance));
      lua.setmetatable(instance, cls);
      _OP__Init__(instance, ...);
      return instance;
    end;
    setfenv(__new__, _M);
    function __dir__(self)
      local v, k;
      local cls = getmetatable(self);
      local ret = {};
      for k, v in pairs(self) do
        ret[k] = true;
      end;
      for k, v in pairs(cls) do
        ret[k] = true;
      end;
      local ret2 = {};
      local idx = 1;
      for k, v in pairs(ret) do
        if not metatable_events_rev[k] then
          ret2[idx] = k;
          idx = (idx + 1);
        end;
      end;
      ret = nil;
      table.sort(ret2);
      local ret3 = {};
      for k, v in pairs(ret2) do
        ret3[k] = str(v);
      end;
      ret2 = nil;
      return list(ret3);
    end;
    setfenv(__dir__, _M);
    function __getattribute__(self, k)
      local v = rawget(self, k);
      if v ~= nil then
        return v;
      end;
      local mt = getmetatable(self);
      v = rawget(mt, k);
      if v ~= nil then
        if lua.type(v) == 'function' then
          return (function(...) return v(self, unpack({...})); end);
        else
          return v;
        end;
      end;
      error(lua.format("Not found '%s' attribute.", k));
    end;
    setfenv(__getattribute__, _M);
    function __setattr__(self, key, value)
      local cls = type(self);
      if BuiltinTypes[cls] and inited then
        local basemsg = "can't set attributes of built-in/extension type ";
        error(TypeError(lua.concat(basemsg, LObj(repr(cls.__name__)))));
      end;
      rawset(self, key, value);
    end;
    setfenv(__setattr__, _M);
    function __delattr__(self, key, value)
      object.__setattr__(self, key, nil);
    end;
    setfenv(__delattr__, _M);
    function __eq__(self, other)
      return self == other;
    end;
    setfenv(__eq__, _M);
    function __ne__(self, other)
      return self ~= other;
    end;
    setfenv(__ne__, _M);
    function __hash__(self, other)
      return id(self);
    end;
    setfenv(__hash__, _M);
    function __str__(self)
      return _OP__Repr__(self);
    end;
    setfenv(__str__, _M);
    function __repr__(self)
      local mtable = getmetatable(self);
      local name = mtable.__name__;
      local oid = id(self);
      oid = lua.format('000000000%X', LObj(oid));
      oid = lua.string.sub(oid, (-BIT_WIDTH));
      return str(lua.format('<object %s at 0x%s>', LObj(name), oid));
    end;
    setfenv(__repr__, _M);
    function __bool__(self)
      return True;
    end;
    setfenv(__bool__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
object = setup_base_class(object);
type = (function(_M)--(type: object)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({object}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {object};
  scope.__name__ = 'type';
  function doload()
    function __getattribute__(cls, key)
      local clsdata = ObjData[cls].c;
      if clsdata ~= nil then
        local value = clsdata[key];
        if value ~= nil then
          return value;
        end;
      end;
      return object.__getattribute__(cls, key);
    end;
    setfenv(__getattribute__, _M);
    function __call__(cls, ...)
      local args = {...};
      return cls.__new__(cls, ...);
    end;
    setfenv(__call__, _M);
    function __repr__(cls)
      return str(lua.concat("<class '", LObj(cls.__name__), "'>"));
    end;
    setfenv(__repr__, _M);
    function mro(cls)
      return list(ObjData[cls.__mro__].v);
    end;
    setfenv(mro, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
type = setup_base_class(type);
local ptype = (function(_M)--(ptype: type)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({type}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {type};
  scope.__name__ = 'ptype';
  function doload()
    function __call__(cls, ...)
      local args = {...};
      if lua.len(args) == 1 then
        require_pyobj(args[1]);
        return getmetatable(args[1]);
      elseif lua.len(args) == 3 then
      else
        error('Unexcepted arguments.');
      end;
    end;
    setfenv(__call__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
ptype = setup_base_class(ptype);
ptype = setup_hide_class(ptype);
setmetatable(object, type);
setmetatable(type, ptype);
setmetatable(ptype, ptype);

BaseException = (function(_M)--(BaseException: object)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({object}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {object};
  scope.__name__ = 'BaseException';
  function doload()
    args = nil;
    function __new__(cls, ...)
      local args = {...};
      local param = tuple(args);
      local instance = object.__new__(cls);
      rawset(instance, 'args', param);
      _OP__Init__(instance, param);
      return instance;
    end;
    setfenv(__new__, _M);
    function __str__(self)
      local length = LObj(len(self.args));
      if length == 0 then
        return str('');
      elseif length == 1 then
        return str(_OP__Getitem__(self.args, int(0)));
      end;
    end;
    setfenv(__str__, _M);
    function __repr__(self)
      local excname = LObj(type(self).__name__);
      return lua.concat(excname, repr(self.args));
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      local excname = LObj(type(self).__name__);
      local value = str(self);
      if LObj(len(value)) > 0 then
        return lua.concat(excname, ': ', LObj(value));
      else
        return lua.concat(excname);
      end;
    end;
    setfenv(__lua__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
BaseException = setup_basic_class(BaseException);
Exception = (function(_M)--(Exception: BaseException)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({BaseException}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {BaseException};
  scope.__name__ = 'Exception';
  function doload()
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
Exception = setup_basic_class(Exception);
TypeError = (function(_M)--(TypeError: Exception)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({Exception}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {Exception};
  scope.__name__ = 'TypeError';
  function doload()
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
TypeError = setup_basic_class(TypeError);
UnstableException = (function(_M)--(UnstableException: Exception)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({Exception}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {Exception};
  scope.__name__ = 'UnstableException';
  function doload()
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
UnstableException = setup_basic_class(UnstableException);
KeyError = (function(_M)--(KeyError: Exception)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({Exception}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {Exception};
  scope.__name__ = 'KeyError';
  function doload()
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
KeyError = setup_basic_class(KeyError);

local BuiltinConstType = (function(_M)--(BuiltinConstType: object)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({object}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {object};
  scope.__name__ = 'BuiltinConstType';
  function doload()
    function __new__(cls, ...)
      local args = {...};
      if not inited then
        local instance = object.__new__(cls, ...);
        _OP__Init__(instance, ...);
        return instance;
      end;
      return cls._get_singleton();
    end;
    setfenv(__new__, _M);
    function _get_singleton(cls)
      error('Not defined.');
    end;
    setfenv(_get_singleton, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
BuiltinConstType = setup_basic_class(BuiltinConstType);
BuiltinConstType = setup_hide_class(BuiltinConstType);
local NotImplementedType = (function(_M)--(NotImplementedType: BuiltinConstType)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({BuiltinConstType}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {BuiltinConstType};
  scope.__name__ = 'NotImplementedType';
  function doload()
    function _get_singleton(cls)
      return NotImplemented;
    end;
    setfenv(_get_singleton, _M);
    function __repr__(self)
      return str('NotImplemented');
    end;
    setfenv(__repr__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
NotImplementedType = setup_basic_class(NotImplementedType);
local EllipsisType = (function(_M)--(EllipsisType: BuiltinConstType)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({BuiltinConstType}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {BuiltinConstType};
  scope.__name__ = 'EllipsisType';
  function doload()
    function _get_singleton(self)
      return Ellipsis;
    end;
    setfenv(_get_singleton, _M);
    function __repr__(self)
      return str('Ellipsis');
    end;
    setfenv(__repr__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
EllipsisType = setup_basic_class(EllipsisType);
local NoneType = (function(_M)--(NoneType: BuiltinConstType)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({BuiltinConstType}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {BuiltinConstType};
  scope.__name__ = 'NoneType';
  function doload()
    function _get_singleton(cls)
      return None;
    end;
    setfenv(_get_singleton, _M);
    function __repr__(self)
      return str('None');
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      return nil;
    end;
    setfenv(__lua__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
NoneType = setup_basic_class(NoneType);
local LuaObject = (function(_M)--(LuaObject: object)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({object}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {object};
  scope.__name__ = 'LuaObject';
  function doload()
    function __init__(self, obj)
      if is_pyobj(obj) then
        error(Exception('Not allowed wrapping python object!'));
      end;
      assert(obj ~= nil);
      ObjData[self].v = obj;
    end;
    setfenv(__init__, _M);
    function __str__(self)
      return str(_OP__Repr__(self));
    end;
    setfenv(__str__, _M);
    function __repr__(self)
      return str(tostring(ObjData[self].v));
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      return ObjData[self].v;
    end;
    setfenv(__lua__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
LuaObject = setup_basic_class(LuaObject);
LuaObject = setup_hide_class(LuaObject);
generator = (function(_M)--(generator: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'generator';
  function doload()
    function __init__(self, obj)
      if is_pyobj(obj) then
        error(TypeError("cannot create 'generator' instances"), 1);
      elseif lua.type(obj) ~= 'thread' then
        error(TypeError("gernerator only accept lua.type 'thread' object."), 1);
      end;
      LuaObject.__init__(self, obj);
    end;
    setfenv(__init__, _M);
    function __next__(self)
      return LObj(genbody)();
    end;
    setfenv(__next__, _M);
    function __repr__(self)
      return str(tostring(ObjData[self].v));
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      local t = ObjData[self].v;
      local function genbody()
        success, value = coroutine.resume(t);
        if not success then
          return nil;
        end;
        return value;
      end;
      return genbody;
    end;
    setfenv(__lua__, _M);
    function __iter__(self)
      return self;
    end;
    setfenv(__iter__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
generator = setup_basic_class(generator);
local function require_lua_sequance(value)
  if lua.type(value) ~= 'table' then
  elseif lua.len(value) == 0 then
    return true;
  elseif value[lua.len(value)] == nil then
  elseif value[1] == nil then
  elseif value[0] ~= nil then
  else
    return true;
  end;
  error(Exception('Not allowed unknown table (or other thing)!'));
end;
list = (function(_M)--(list: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'list';
  function doload()
    function __init__(self, value)
      local v, k;
      local core = {};
      local new = nil;
      local cur = core;
      for k, v in pairs(value) do
        new = {};
        new.v = v;
        new.p = cur;
        cur.n = new;
        cur = new;
      end;
      if core.n then
        core.n.p = nil;
      end;
      if new and new.p then
        core.p = new;
      end;
      LuaObject.__init__(self, core);
    end;
    setfenv(__init__, _M);
    function __getitem__(self, x)
      x = _OP__Index__(x);
      x = LObj(x);
      local cur = ObjData[self].v;
      assert(x >= 0);
      while x ~= 0 do
        cur = cur.n;
        x = (x - 1);
      end;
      return cur.v;
    end;
    setfenv(__getitem__, _M);
    function __repr__(self)
      local ret = {};
      local idx = 1;
      local sep = '';
      ret[idx] = '[';
      idx = (idx + 1);
      local cur = ObjData[self].v.n;
      while cur ~= nil do
        ret[idx] = sep;
        idx = (idx + 1);
        ret[idx] = LObj(repr(cur.v));
        idx = (idx + 1);
        sep = ', ';
        cur = cur.n;
      end;
      ret[idx] = ']';
      idx = (idx + 1);
      return table.concat(ret);
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      local ret = {};
      local idx = 1;
      local cur = ObjData[self].v;
      while cur ~= nil do
        ret[idx] = cur.v;
        idx = (idx + 1);
        cur = cur.n;
      end;
      return ret;
    end;
    setfenv(__lua__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
list = setup_basic_class(list);
tuple = (function(_M)--(tuple: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'tuple';
  function doload()
    function __init__(self, obj)
      LuaObject.__init__(self, obj);
      assert(require_lua_sequance(obj));
    end;
    setfenv(__init__, _M);
    function __repr__(self)
      return self.make_repr('(', ')');
    end;
    setfenv(__repr__, _M);
    function __len__(self)
      return int(lua.len(ObjData[self].v));
    end;
    setfenv(__len__, _M);
    function __getitem__(self, x)
      x = _OP__Index__(x);
      x = LObj(x);
      assert(x >= 0);
      return ObjData[self].v[(LObj(x) + 1)];
    end;
    setfenv(__getitem__, _M);
    function __repr__(self)
      local v, k;
      local value = ObjData[self].v;
      local ret = {};
      local idx = 1;
      local sep = '';
      ret[idx] = '(';
      idx = (idx + 1);
      for k, v in pairs(value) do
        ret[idx] = sep;
        idx = (idx + 1);
        ret[idx] = LObj(repr(v));
        idx = (idx + 1);
        sep = ', ';
      end;
      if lua.len(value) == 1 then
        ret[idx] = ',';
        idx = (idx + 1);
      end;
      ret[idx] = ')';
      idx = (idx + 1);
      return table.concat(ret);
    end;
    setfenv(__repr__, _M);
    function __iter__(self)
      local value = ObjData[self].v;
      local idx = 1;
      local function body()
        while value[idx] ~= nil do
          _OP__Yield__(value[idx]);
          idx = (idx + 1);
        end;
      end;
      body = _OP__SetupGenFunc__(body);
      return body();
    end;
    setfenv(__iter__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
tuple = setup_basic_class(tuple);
dict = (function(_M)--(dict: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'dict';
  function doload()
    function __init__(self, obj)
      LuaObject.__init__(self, {});
      ObjData[self].changed = false;
      ObjData[self].length = 0;
      dict.update(self, obj);
    end;
    setfenv(__init__, _M);
    function update(self, obj)
      local v, k;
      for k, v in pairs(obj) do
        _OP__Setitem__(self, k, v);
      end;
    end;
    setfenv(update, _M);
    function __setitem__(self, key, value)
      local t, a;
      assert(require_pyobj(key, value));
      local data = ObjData[self];
      local target = data.v;
      local hk = _OP__Hash__(key);
      if target[hk] == nil then
        data.changed = true;
        data.length = (data.length + 1);
        target[hk] = {{key, value}};
        return;
      end;
      local line = target[hk];
      for a, t in pairs(line) do
        if _OP__Eq__(key, t[1]) then
          t[1] = key;
          t[2] = value;
          return;
        end;
      end;
      data.changed = true;
      data.length = (data.length + 1);
      line[(lua.len(line) + 1)] = {key, value};
    end;
    setfenv(__setitem__, _M);
    function __getitem__(self, key, value)
      local t, a;
      assert(require_pyobj(key, value));
      local data = ObjData[self];
      local target = data.v;
      local hk = _OP__Hash__(key);
      if target[hk] == nil then
        error(KeyError(key));
      end;
      local line = target[hk];
      for a, t in pairs(line) do
        if _OP__Eq__(key, t[1]) then
          return t[2];
        end;
      end;
      error(KeyError(key));
    end;
    setfenv(__getitem__, _M);
    function __lua__(self)
    end;
    setfenv(__lua__, _M);
    function __repr__(self)
      local _, line, r;
      local target = ObjData[self].v;
      local ret = {};
      local idx = 1;
      local sep = '';
      ret[idx] = '{';
      idx = (idx + 1);
      for _, line in pairs(target) do
        for _, r in pairs(line) do
          ret[idx] = sep;
          idx = (idx + 1);
          ret[idx] = LObj(repr(r[1]));
          idx = (idx + 1);
          ret[idx] = ': ';
          idx = (idx + 1);
          ret[idx] = LObj(repr(r[2]));
          idx = (idx + 1);
          sep = ', ';
        end;
      end;
      ret[idx] = '}';
      idx = (idx + 1);
      return table.concat(ret);
    end;
    setfenv(__repr__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
dict = setup_basic_class(dict);
str = (function(_M)--(str: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'str';
  function doload()
    function __init__(self, value)
      if is_pyobj(value) then
        value = _OP__Str__(value);
        value = LObj(value);
      end;
      ObjData[self].v = value;
    end;
    setfenv(__init__, _M);
    function __str__(self)
      return self;
    end;
    setfenv(__str__, _M);
    function __repr__(self)
      return str(lua.concat("'", ObjData[self].v, "'"));
    end;
    setfenv(__repr__, _M);
    function __len__(self)
      return int(lua.len(ObjData[self].v));
    end;
    setfenv(__len__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
str = setup_basic_class(str);
local LuaNum = (function(_M)--(LuaNum: LuaObject)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaObject}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaObject};
  scope.__name__ = 'LuaNum';
  function doload()
    function __add__(self, other)
      return (ObjData[self].v + ObjData[other].v);
    end;
    setfenv(__add__, _M);
    function __sub__(self, other)
      return (ObjData[self].v - ObjData[other].v);
    end;
    setfenv(__sub__, _M);
    function __mul__(self, other)
      return (ObjData[self].v * ObjData[other].v);
    end;
    setfenv(__mul__, _M);
    function __truediv__(self, other)
      return float((ObjData[self].v / ObjData[other].v));
    end;
    setfenv(__truediv__, _M);
    function __radd__(self, other)
      return (ObjData[other].v + ObjData[self].v);
    end;
    setfenv(__radd__, _M);
    function __rsub__(self, other)
      return (ObjData[other].v - ObjData[self].v);
    end;
    setfenv(__rsub__, _M);
    function __rmul__(self, other)
      return (ObjData[other].v * ObjData[self].v);
    end;
    setfenv(__rmul__, _M);
    function __rtruediv__(self, other)
      return float((ObjData[other].v / ObjData[self].v));
    end;
    setfenv(__rtruediv__, _M);
    function __eq__(self, other)
      return bool(ObjData[self].v == ObjData[other].v);
    end;
    setfenv(__eq__, _M);
    function __ne__(self, other)
      return bool(ObjData[self].v ~= ObjData[other].v);
    end;
    setfenv(__ne__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
LuaNum = setup_basic_class(LuaNum);
LuaNum = setup_hide_class(LuaNum);
local function int_chk_other(other)
  if isinstance(other, int) == False then
    return NotImplemented;
  end;
end;
int = (function(_M)--(int: LuaNum)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaNum}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaNum};
  scope.__name__ = 'int';
  function doload()
    function __add__(self, other)
      return int_chk_other(other) or int(LuaNum.__add__(self, other));
    end;
    setfenv(__add__, _M);
    function __sub__(self, other)
      return int_chk_other(other) or int(LuaNum.__sub__(self, other));
    end;
    setfenv(__sub__, _M);
    function __mul__(self, other)
      return int_chk_other(other) or int(LuaNum.__mul__(self, other));
    end;
    setfenv(__mul__, _M);
    function __radd__(self, other)
      return int_chk_other(other) or int(LuaNum.__radd__(self, other));
    end;
    setfenv(__radd__, _M);
    function __rsub__(self, other)
      return int_chk_other(other) or int(LuaNum.__rsub__(self, other));
    end;
    setfenv(__rsub__, _M);
    function __rmul__(self, other)
      return int_chk_other(other) or int(LuaNum.__rmul__(self, other));
    end;
    setfenv(__rmul__, _M);
    function __hash__(self)
      return ObjData[self].v;
    end;
    setfenv(__hash__, _M);
    function __index__(self)
      return int(ObjData[self].v);
    end;
    setfenv(__index__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
int = setup_basic_class(int);
local BOOL_TRUE = 1;
local BOOL_FALSE = 0;
bool = (function(_M)--(bool: int)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({int}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {int};
  scope.__name__ = 'bool';
  function doload()
    function __init__(cls)
    end;
    setfenv(__init__, _M);
    function __new__(cls, value)
      if not inited then
        local instance = object.__new__(cls);
        if value == true then
          value = BOOL_TRUE;
        elseif value == false then
          value = BOOL_FALSE;
        end;
        ObjData[instance].v = value;
        return instance;
      end;
      if is_pyobj(value) then
        value = _OP__Bool__(value);
      else
        value = value and true or false;
      end;
      if value == true then
        return True;
      elseif value == false then
        return False;
      elseif is_pyobj(value) and type(value) == bool then
        return value;
      end;
      error('__Bool__ are returned unknown value.');
    end;
    setfenv(__new__, _M);
    function __bool__(self)
      return self;
    end;
    setfenv(__bool__, _M);
    function __repr__(self)
      local value = ObjData[self].v;
      if value == BOOL_TRUE then
        return str('True');
      elseif value == BOOL_FALSE then
        return str('False');
      end;
    end;
    setfenv(__repr__, _M);
    function __lua__(self)
      local value = ObjData[self].v;
      if value == BOOL_TRUE then
        return true;
      elseif value == BOOL_FALSE then
        return false;
      end;
    end;
    setfenv(__lua__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
bool = setup_basic_class(bool);
local function float_chk_other(other)
  if isinstance(other, int) == True then
    return;
  elseif isinstance(other, float) == True then
    return;
  else
    return NotImplemented;
  end;
end;
float = (function(_M)--(float: LuaNum)
  local scope = setmetatable({}, {__index=_M})
;(function(o,c,k,v)
    for k,c in pairs({LuaNum}) do
      for k,v in pairs(c) do o[k]=v end
    end
  end)(scope);
  scope.__bases__ = {LuaNum};
  scope.__name__ = 'float';
  function doload()
    function __add__(self, other)
      return float_chk_other(other) or float(LuaNum.__add__(self, other));
    end;
    setfenv(__add__, _M);
    function __sub__(self, other)
      return float_chk_other(other) or float(LuaNum.__sub__(self, other));
    end;
    setfenv(__sub__, _M);
    function __mul__(self, other)
      return float_chk_other(other) or float(LuaNum.__mul__(self, other));
    end;
    setfenv(__mul__, _M);
    function __radd__(self, other)
      return float_chk_other(other) or float(LuaNum.__radd__(self, other));
    end;
    setfenv(__radd__, _M);
    function __rsub__(self, other)
      return float_chk_other(other) or float(LuaNum.__rsub__(self, other));
    end;
    setfenv(__rsub__, _M);
    function __rmul__(self, other)
      return float_chk_other(other) or float(LuaNum.__rmul__(self, other));
    end;
    setfenv(__rmul__, _M);
  end;
  setfenv(doload, scope);
  doload();
  return scope;
end)(_M);
float = setup_basic_class(float);
local function parse_func_args(args, kwargs, al, a, ...)
  local fargs_ = {...};
  return parse_func_kwargs(args, kwargs, al, a, 0, None);
end;
local function parse_func_kwargs(args, kwargs, al, a, kl, k, ...)
  local fargs_ = {...};
  local ret = {};
  local idx = 1;
  local fargs = fargs_;
  assert(isinstance(args, tuple));
  args = LObj(args);
  kwargs = LObj(kwargs);
  local total_count = (al + kl);
  local count = 0;
  if args ~= nil then
    local tmp = {};
    local x = lua.length(args);
    local y = al;
    local z = (x - y);
    while count > 0 do
      tmp[idx] = args[idx];
      idx = (idx + 1);
      count = (count - 1);
    end;
  end;
  if kwargs ~= nil then
  end;
end;
function parse_func_args(args, kwargs, ...)
  local fargs_ = {...};
end;
local function inital()
  local _, cls;
  for cls, _ in pairs(InitalBuiltinTypes) do
    register_builtins_class(cls);
    BuiltinTypes[cls] = true;
  end;
  InitalBuiltinTypes = nil;
  _M['NotImplemented'] = NotImplementedType();
  _M['Ellipsis'] = EllipsisType();
  _M['None'] = NoneType();
  _M['True'] = bool(true);
  _M['False'] = bool(false);
  if startup then
    local final = os.clock();
    lua.print(lua.format('Startup: %i ms', ((final - startup) * 1000)));
  end;
  return true;
end;
inited = inital();
assert(inited);
local i = 0;
local e = 0;
while i < 25000 do
  i = (i + 1);
  int(0);
  c = 0;
  for k, v in pairs(Obj_FromID) do
    c = (c + 1);
  end;
  if e ~= c then
    lua.print(e, c);
    if os.sleep then
      os.sleep(0);
    end;
  end;
  e = (c + 1);
end;
local final = os.clock();
lua.print(i, (final - startup));
c = 0;
local r = dict({[int(1)] = int(2), [int(3)] = int(4), [int(1)] = int(3)});
print('!', _OP__Getitem__(r, int(3)));
print(a, b, c);
print(lua.format('%s', 'test'));
print(_OP__Truediv__(int(3), int(6)));
print(int.mro());
print(dir(object()));
print(_OP__Add__(True, True));
